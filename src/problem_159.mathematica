(* Project Euler 159: https://projecteuler.net/problem=159

For each integer n with 1<n<10^6, define mdrs(n) as the maximum over all multiplicative
factorizations of n (without using factor 1) of the sum of decimal digital roots of the
individual factors. The required output is Sum_{n=2}^{999999} mdrs(n).

The decimal digital root is dr(k)=1+Mod[k-1,9] for k>=1. Any factorization of n can be split
into two nontrivial subproducts d and n/d, and conversely concatenating optimal factorizations
of d and n/d gives a valid factorization of n. Therefore
mdrs(n)=Max[dr(n), Max_{d|n, 1<d<n}(mdrs(d)+mdrs(n/d))].
This is an exact dynamic-programming recurrence on the divisibility DAG, topologically ordered
by magnitude because each proper divisor pair uses values strictly below n.

For fixed n it is sufficient to scan divisors d<=sqrt(n), since the complementary factor is
q=n/d and every unordered pair appears exactly once. The total number of such transitions up
to N is Theta(sum_{n<=N} tau(n))=Theta(N log N), with low memory overhead from a single mdrs
array. At N=10^6 this is comfortably feasible.

Parallelization is applied to the expensive arithmetic preprocessing inside each monotone n
chunk: divisor lists for all n in the chunk are independent, so they are generated by
ParallelMap across available kernels. The DP update itself remains deterministic and ordered
within each chunk to preserve recurrence correctness; chunk boundaries are processed in
ascending order. Aggregation is purely associative (Max for each n, then Total at the end),
so there is no race-sensitive shared mutation.

The Wolfram Language script uses exact integer arithmetic only, digital-root initialization via
modular reduction, divisor extraction with Divisors and TakeWhile, dynamic kernel launch based
on $ProcessorCount, and chunked parallel workload distribution. The main function solve[]
returns the exact integer answer with no side output. *)

nCores = $ProcessorCount;

ClearAll[
  properDivisorsLE,
  solve
];

properDivisorsLE[n_Integer?Positive] := Module[
  {middle},
  middle = Rest[Most[Divisors[n]]];
  TakeWhile[middle, #*# <= n &]
];

solve[] := Module[
  {
    limit = 10^6,
    kernelsTarget,
    workers,
    chunkSize,
    ranges,
    mdrs,
    range,
    start,
    finish,
    numbers,
    divisorLists,
    i,
    k,
    n,
    best,
    d,
    q
  },
  mdrs = ConstantArray[0, limit - 1];
  Do[
    mdrs[[n]] = 1 + Mod[n - 1, 9],
    {n, 2, limit - 1}
  ];
  kernelsTarget = Max[0, nCores - 1];
  If[
    kernelsTarget > $KernelCount,
    TimeConstrained[
      Block[
        {$Messages = {}},
        Check[
          LaunchKernels[kernelsTarget - $KernelCount],
          Null
        ]
      ],
      10,
      Null
    ]
  ];
  workers = Max[1, Min[kernelsTarget, Length[Kernels[]]]];
  chunkSize = Max[2000, Ceiling[(limit - 2)/workers]];
  ranges = Table[
    {s, Min[limit - 1, s + chunkSize - 1]},
    {s, 2, limit - 1, chunkSize}
  ];
  If[workers > 1, DistributeDefinitions[properDivisorsLE]];
  Do[
    range = ranges[[i]];
    start = range[[1]];
    finish = range[[2]];
    numbers = Range[start, finish];
    divisorLists = If[
      workers > 1,
      ParallelMap[
        properDivisorsLE,
        numbers,
        Method -> "CoarsestGrained"
      ],
      Map[properDivisorsLE, numbers]
    ];
    Do[
      n = numbers[[k]];
      best = mdrs[[n]];
      Do[
        q = Quotient[n, d];
        best = Max[best, mdrs[[d]] + mdrs[[q]]],
        {d, divisorLists[[k]]}
      ];
      mdrs[[n]] = best,
      {k, 1, Length[numbers]}
    ],
    {i, 1, Length[ranges]}
  ];
  Total[mdrs[[2 ;; limit - 1]]]
];

solve[]
