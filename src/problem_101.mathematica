(*
Project Euler Problem 101
URL: https://projecteuler.net/problem=101

Define u(n)=1-n+n^2-n^3+...+n^10. For each k>=1, let OP(k,n) be the unique polynomial of degree at most k-1
that interpolates u(1),...,u(k). If OP(k,n) ever differs from u(n), then OP(k,n) is a bad optimum polynomial.
Its first incorrect term (FIT) is OP(k,m) at the smallest index m with OP(k,m)!=u(m). The task is to sum all
FIT values generated by these BOPs for the given generating polynomial.

Because sample points are consecutive integers, Newton forward interpolation is the natural reduction. From the
first k values, build the forward-difference table and take d_j as the first entry in the j-th difference row,
j=0,...,k-1. Then OP(k,n)=Sum_{j=0}^{k-1} Binomial[n-1,j] d_j exactly. This avoids symbolic coefficient solving
and keeps all arithmetic in exact integers and rationals.

Here deg(u)=10. For k<=10, Delta_k(n)=u(n)-OP(k,n) is a nonzero degree-10 polynomial with roots at n=1,...,k.
A nonzero degree-10 polynomial has at most 10 roots, so at least one disagreement must occur by n=11. Hence each
FIT is obtained by scanning n from k+1 through 11 and selecting the first mismatch.

Complexity is tiny but explicit: building the difference prefix for order k costs O(k^2), checking candidates costs
O(k), and summing over k=1..10 gives O(sum k^2)=O(10^3) integer operations with small memory. In degree-d form,
this direct method scales as O(d^3), fully feasible for this Euler input.

Parallelism is embarrassingly parallel over interpolation order k. Each core handles a disjoint k, computes its FIT
independently from local data, and returns one integer. Aggregation is a deterministic associative reduction via
Total on the FIT list, so no shared mutable state or race-prone updates are needed.

The Wolfram Language implementation uses NestWhileList with Differences for forward differences, Binomial for Newton
evaluation, ParallelMap across k=1..10, and exact arithmetic throughout. Kernels are launched using $ProcessorCount,
definitions are distributed once, and solve[] returns the required exact sum.
*)

nCores = $ProcessorCount;
LaunchKernels[nCores];

u[n_Integer] := (1 + n^11)/(1 + n);

fitForK[k_Integer, seq_List] := Module[{layers, firsts, idx, opAt, nFIT},
  layers = NestWhileList[Differences, seq[[;; k]], Length[#] > 1 &];
  firsts = First /@ layers;
  idx = Range[0, Length[firsts] - 1];
  opAt[n_Integer] := Total[Binomial[n - 1, idx] * firsts];
  nFIT = First[Select[Range[k + 1, 11], opAt[#] =!= seq[[#]] &]];
  opAt[nFIT]
];

solve[] := Module[{seq, fits},
  seq = u /@ Range[11];
  DistributeDefinitions[fitForK, seq];
  fits = ParallelMap[fitForK[#, seq] &, Range[10], Method -> "FinestGrained"];
  Total[fits]
];

solve[]
