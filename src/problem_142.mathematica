(* Project Euler 142: https://projecteuler.net/problem=142

  The goal is to find the minimum x + y + z with positive integers x > y > z such that
  x+y, x-y, x+z, x-z, y+z, and y-z are all perfect squares.

  Write x+y = u^2 and x-y = v^2 with u > v and equal parity. Then
  x = (u^2+v^2)/2 and y = (u^2-v^2)/2. Therefore each admissible pair (x,y) comes from one
  pair (u,v), and all such pairs are generated by scanning u and parity-matched v.
  A valid triple (x,y,z) arises when one x has at least two generated values y and z and,
  additionally, y+z and y-z are squares.

  This gives an incremental algorithm. For each u, generate all (x,y), look up the previous
  y-values already seen for that x, and test the new pairings. The complexity is
  O(U^2 + sum_x r_x^2), where U is the largest u reached and r_x is the bucket size for x.
  Here r_x is small (sum-of-two-squares multiplicity), so the method is practical.

  Early termination is rigorous: if S is any candidate sum, then x+y is one of its required
  squares and x+y < x+y+z = S. Hence any better future solution than current best B must have
  u^2 = x+y < B, i.e. u <= floor(sqrt(B-1)). Once the scan index exceeds this bound, the
  current best is globally minimal.

  The implementation uses exact integer arithmetic, fast square tests by modular filtering
  plus integer roots, and an incremental Association-based state with bounded live keys. *)

iSqrt[n_Integer] := Floor[Sqrt[n]];

squarePairQ[a_Integer, b_Integer] := Module[{d = a - b, s = a + b, rd, rs, qd, qs},
  If[d <= 0,
    False,
    rd = BitAnd[d, 15];
    rs = BitAnd[s, 15];
    If[
      (rd =!= 0 && rd =!= 1 && rd =!= 4 && rd =!= 9) ||
      (rs =!= 0 && rs =!= 1 && rs =!= 4 && rs =!= 9),
      False,
      qd = iSqrt[d];
      qs = iSqrt[s];
      qd qd == d && qs qs == s
    ]
  ]
];

solve[] := Module[
  {
    best = Infinity, uLimit = Infinity, byX = <||>, u = 2, u2, vStart, v2, x, y, node,
    curr, z, hi, lo, t, keepMin
  },
  While[u <= uLimit,
    u2 = u u;
    keepMin = Quotient[u2, 2];
    If[Mod[u, 32] == 0,
      If[best < Infinity,
        byX = KeySelect[byX, (# >= keepMin && # < best) &],
        byX = KeySelect[byX, # >= keepMin &]
      ]
    ];
    vStart = If[EvenQ[u], 2, 1];
    Do[
      v2 = v v;
      x = Quotient[u2 + v2, 2];
      If[best < Infinity && x >= best,
        Continue[]
      ];
      y = Quotient[u2 - v2, 2];
      node = Lookup[byX, x, 0];
      curr = node;
      While[curr =!= 0,
        z = curr[[1]];
        hi = If[y > z, y, z];
        lo = If[y > z, z, y];
        t = x + hi + lo;
        If[t < best && squarePairQ[hi, lo],
          best = t;
          uLimit = iSqrt[best - 1]
        ];
        curr = curr[[2]]
      ];
      byX[x] = {y, node},
      {v, vStart, u - 1, 2}
    ];
    u++
  ];
  best
];

solve[]
