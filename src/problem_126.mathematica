(* Project Euler Problem 126 - https://projecteuler.net/problem=126

   For a cuboid with integer side lengths a, b, c, consider wrapping it with successive outer layers of unit cubes.
   Let C(n) be the number of distinct cuboids that have some layer containing exactly n cubes. The problem asks for the
   least n such that C(n) = 1000.

   Ordering dimensions as a <= b <= c removes permutation duplicates, so each geometric cuboid is counted once. The
   first layer size is L1 = 2(ab + ac + bc). For layer index k >= 1, direct face-edge-corner accounting gives
   L(a, b, c, k) = 2(ab + ac + bc) + 4(k - 1)(a + b + c + k - 2). Equivalently, with s = a + b + c and t = k - 1,
   L = L1 + 4 t(s + t - 1), a strictly increasing quadratic in t.

   Hence for fixed (a, b, c) and an upper limit N, all feasible layers are generated by monotone iteration until
   exceeding N. The increment between consecutive layers is affine:
   L_{k+1} - L_k = 4(a + b + c) + 8(k - 1), so each sequence is produced in O(number of layers) with integer arithmetic.

   Search bounds follow from minimal constructions. Since L1 >= 6 a^2 when b = c = a, we only need
   a <= floor(sqrt(N/6)). For fixed a and b, minimal c is b, giving L1 >= 2(2ab + b^2), which bounds b. For fixed
   (a, b), c is increased until L1 > N. Thus the enumeration is finite and near-quadratic in practical range.

   We compute C(1), ..., C(N) for a candidate N and locate the first index where C(n) = 1000. If absent, N is doubled
   and recomputed; for Euler data, N = 20000 already contains the solution, so runtime is small.

   Parallelization is performed over disjoint contiguous ranges of a. Each kernel independently accumulates a local
   count vector for all n <= N from its assigned a-block, then vectors are aggregated by elementwise Total, which is
   associative and race-free. This distributes the dominant cuboid-layer enumeration across all CPU cores.

   The Wolfram Language implementation uses exact integer loops for tight control, ParallelMap on a-range chunks,
   deterministic reduction of local count arrays, and a solve[] driver that returns the required least n.
*)

nCores = $ProcessorCount;
LaunchKernels[];

countChunk[aRange_List, maxN_Integer?Positive] := Module[{counts, a, b, c, n1, s, n, delta},
  counts = ConstantArray[0, maxN];
  For[a = aRange[[1]], a <= aRange[[2]], a++,
    If[6 a a > maxN, Break[]];
    For[b = a, True, b++,
      If[2 (2 a b + b b) > maxN, Break[]];
      For[c = b, True, c++,
        n1 = 2 (a b + a c + b c);
        If[n1 > maxN, Break[]];
        s = a + b + c;
        n = n1;
        delta = 4 s;
        While[n <= maxN,
          counts[[n]]++;
          n += delta;
          delta += 8
        ]
      ]
    ]
  ];
  counts
]

buildCounts[maxN_Integer?Positive] := Module[{aMax, chunkSize, ranges, partials},
  aMax = Floor[Sqrt[maxN/6]];
  chunkSize = Max[1, Ceiling[aMax/nCores]];
  ranges = Table[{i, Min[i + chunkSize - 1, aMax]}, {i, 1, aMax, chunkSize}];
  partials = ParallelMap[countChunk[#, maxN] &, ranges];
  Total[partials]
]

DistributeDefinitions[countChunk];

solve[] := Module[{target, maxN, counts, pos},
  target = 1000;
  maxN = 20000;
  While[True,
    counts = buildCounts[maxN];
    pos = FirstPosition[counts, target, Missing["NotFound"]];
    If[pos =!= Missing["NotFound"],
      Return[pos[[1]]]
    ];
    maxN *= 2
  ]
]

solve[]
