(* Project Euler Problem 140 - https://projecteuler.net/problem=140

   Let G_1 = 1, G_2 = 4, G_k = G_{k-1} + G_{k-2}, and A_G(x) = Sum_{k>=1} G_k x^k. A positive integer n is a
   modified golden nugget when A_G(x) = n for some rational x. The task is the sum of the first thirty such n.

   The generating function is A_G(x) = x (1 + 3 x)/(1 - x - x^2). Setting A_G(x) = n gives
   (n + 3) x^2 + (n + 1) x - n = 0.
   Rational x is equivalent to square discriminant m^2 = (n + 1)^2 + 4 n (n + 3) = 5 n^2 + 14 n + 1.
   After completing the square:
   (5 n + 7)^2 - 5 m^2 = 44.
   So nuggets correspond exactly to integer points (u, v) on u^2 - 5 v^2 = 44 with u == 2 (mod 5), via n = (u - 7)/5.

   The unit group of Z[Sqrt[5]] is generated by 9 + 4 Sqrt[5]. Multiplying a solution by this unit advances on the same
   Pell orbit; to preserve u == 2 (mod 5) we use the square unit 161 + 72 Sqrt[5], yielding
   (u, v) -> (161 u + 360 v, 72 u + 161 v).
   For this congruence class there are six positive reduced orbits, with minimal representatives
   (17, 7), (32, 14), (112, 50), (217, 97), (767, 343), (1487, 665).
   Iterating the map on these six seeds generates all positive nuggets exactly once within each orbit.

   Hence we produce enough terms from each orbit, convert by n = (u - 7)/5, merge all values, sort, and sum the first 30.
   Growth is exponential in orbit index, so only O(log N) orbit steps are needed for any magnitude cutoff; for fixed
   target 30, work is constant-scale and trivial.

   Parallelization is natural because the six Pell orbits are independent. Each kernel computes one or more orbit lists,
   then partial lists are merged by Join, deduplicated, sorted, and reduced by Total. This aggregation is associative and
   deterministic, with no shared mutable state.

   The Wolfram Language implementation uses exact integers only, NestList for orbit iteration, ParallelMap over seeds,
   and a single solve[] entry point that returns the exact Project Euler answer.
*)

nCores = $ProcessorCount;
If[Length[Kernels[]] == 0, LaunchKernels[]];
If[Length[Kernels[]] < nCores, LaunchKernels[nCores - Length[Kernels[]]]];

nextPair[{u_Integer, v_Integer}] := {161 u + 360 v, 72 u + 161 v}

orbitNuggets[seed : {u0_Integer, v0_Integer}, terms_Integer?Positive] := Module[{pairs},
  pairs = NestList[nextPair, seed, terms - 1];
  Quotient[#[[1]] - 7, 5] & /@ pairs
]

DistributeDefinitions[nextPair, orbitNuggets];

solve[] := Module[{target, seeds, termsPerOrbit, raw, nuggets},
  target = 30;
  seeds = {{17, 7}, {32, 14}, {112, 50}, {217, 97}, {767, 343}, {1487, 665}};
  termsPerOrbit = target;
  raw = Join @@ ParallelMap[
    orbitNuggets[#, termsPerOrbit] &,
    seeds,
    Method -> "CoarsestGrained"
  ];
  nuggets = Sort[DeleteDuplicates[raw]];
  Total[Take[nuggets, target]]
]

solve[]
