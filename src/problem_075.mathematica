(*
  Project Euler Problem 75: Singular Integer Right Triangles
  URL: https://projecteuler.net/problem=075

  Problem Statement:
  Given an integer L representing the length of a wire, find how many values of L <= 1,500,000 allow forming exactly
  one integer right angle triangle (with side lengths a, b, c such that a + b + c = L). In other words, count the
  number of L in the range [1, 1,500,000] such that there is a unique Pythagorean triple (a, b, c) summing to L.

  Mathematical Analysis:
  We use the Euclidean formula for generating Pythagorean triples. A primitive triple (a, b, c) is generated by integers
  m > n > 0 with gcd(m, n) = 1 and m, n having opposite parity (one odd, one even). The sides are:
  a = m^2 - n^2, b = 2mn, c = m^2 + n^2.
  The perimeter is L = a + b + c = (m^2 - n^2) + 2mn + (m^2 + n^2) = 2m^2 + 2mn = 2m(m + n).
  Any non-primitive triple is a multiple k of a primitive triple. Thus, any valid perimeter L can be written as
  L = k * 2m(m + n) for some integer k >= 1.
  
  Constraints:
  We are given L_max = 1,500,000.
  From 2m(m + n) <= L_max, since n >= 1, we have 2m^2 < L_max => m < Sqrt(L_max / 2) = Sqrt(750,000) approx 866.
  We iterate over m from 2 to ~866. For each m, we iterate n from 1 to m-1.
  We check if gcd(m, n) == 1 and Mod[m - n, 2] == 1 (opposite parity).
  If valid, we have a primitive perimeter p = 2m(m + n). We then mark all multiples k*p <= L_max in a frequency array.
  
  Complexity:
  The number of pairs (m, n) is roughly proportional to m_max^2 / 2, which is O(L_max).
  For each primitive perimeter, we mark its multiples. The total work is proportional to Sum(L_max / p) over all
  primitive p. This sums to roughly O(L_max log L_max). With L_max = 1.5 * 10^6, this is computationally trivial
  (tens of millions of operations), well within a second on modern CPUs.

  Parallelization Strategy:
  While the marking process is essentially a scatter operation into a shared array (histogram), the generation of
  primitive triples can be parallelized. However, given the small problem size and the overhead of synchronization for
  a shared array, a simple partitioning of the 'm' loop with local accumulation followed by a global merge is optimal.
  Each processor core will compute a sparse association or list of (Perimeter -> Count) for its subset of m values.
  Finally, we sum these counts. Alternatively, since shared memory write conflicts are possible if multiple cores write
  to the same L (though rare for distinct primitive roots), using `ParallelTable` to generate lists of perimeters and
  then flattening and tallying is safe and idiomatic.

  Implementation Plan:
  1. Define L_max = 1,500,000.
  2. Use ParallelTable to iterate m from 2 to Floor[Sqrt[L_max/2]].
  3. Inside, iterate n from 1 to m-1.
  4. Select pairs (m, n) satisfying primitive constraints.
  5. Calculate primitive perimeter p = 2m(m+n).
  6. Generate all multiples {p, 2p, 3p, ...} <= L_max.
  7. Flatten the results from all cores into a single list of perimeters.
  8. Use `Counts` or `Tally` to compute frequencies.
  9. Count how many perimeters have a frequency of exactly 1.
*)

solve[] := Module[{Lmax, mMax, nCores, perimeters, counts},
  Lmax = 1500000;
  mMax = Floor[Sqrt[Lmax/2]];
  nCores = $ProcessorCount;

  perimeters = ParallelTable[
    Module[{p, localPerimeters = {}},
      Do[
        If[GCD[m, n] == 1 && OddQ[m - n],
          p = 2 * m * (m + n);
          If[p <= Lmax,
            localPerimeters = Join[localPerimeters, Range[p, Lmax, p]]
          ]
        ],
        {n, 1, m - 1}
      ];
      localPerimeters
    ],
    {m, 2, mMax},
    Method -> "CoarsestGrained"
  ];

  perimeters = Flatten[perimeters];

  counts = Counts[perimeters];

  Count[Values[counts], 1]
]

solve[]