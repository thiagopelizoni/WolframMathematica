(* Project Euler 141: https://projecteuler.net/problem=141

   We must compute the sum of all integers n < 10^12 that are both perfect squares and
   progressive. Here n is progressive when n = d q + r with 0 < r < d, and d, q, r are
   consecutive terms of a geometric progression in some order.

   Any integer geometric triple can be parameterized as a b^2, a b c, a c^2 with c > b > 0
   and gcd(b, c) = 1. Because r < d, the remainder cannot be the largest term. If r were
   the middle term, we would get n = t (t + 1), t = a b c, impossible for a nonzero square.
   Thus every progressive square is generated by r = a b^2 and {d, q} = {a b c, a c^2},
   yielding n = a b (a c^3 + b). This gives a complete reduction for square targets.

   For fixed c and b, n increases strictly with a. From n >= a^2 b c^3 we obtain
   a <= floor(sqrt((N - 1)/(b c^3))), N = 10^12. Also, at a = 1 we need b (c^3 + b) < N,
   so b <= min(c - 1, floor((N - 1)/c^3)); this strongly truncates b for large c.
   Hence c only ranges to N^(1/3), and total candidates are
   sum_{c,b} O(sqrt(N/(b c^3))) = O(N^(1/2) log N), fully feasible for Euler bounds.

   Parallel work is split by c, with independent subproblems and associative aggregation.
   Fine-grained scheduling balances heavy small-c tasks and lighter large-c tasks.
   Kernels produce local hits, then we combine deterministically via Flatten, Union, Total.

   The Wolfram implementation uses exact integer arithmetic only: CoprimeQ for reduced ratios,
   Floor[Sqrt[...]] for integer-root bounds and square checks, Reap/Sow for local collection,
   and ParallelMap for the dominant loop. The script is deterministic and self-contained. *)

nCores = $ProcessorCount;
If[Length[Kernels[]] < nCores,
  LaunchKernels[nCores - Length[Kernels[]]]
];

iSqrt[n_Integer] := Floor[Sqrt[n]];

squareQ[n_Integer] := Module[{s = iSqrt[n]},
  s s == n
];

solve[] := Module[
  {limit = 10^12, cMax = 1, perC, squares},
  While[(cMax + 1)^3 < limit,
    cMax++
  ];
  DistributeDefinitions[iSqrt, squareQ];
  perC = With[{limitLocal = limit},
    ParallelMap[
      Function[c,
        Module[{c3 = c^3, bMax, bucket},
          bMax = Min[c - 1, Quotient[limitLocal - 1, c3]];
          bucket = Reap[
            Do[
              If[CoprimeQ[b, c],
                Module[{aMax, n},
                  aMax = iSqrt[Quotient[limitLocal - 1, b c3]];
                  Do[
                    n = a b (a c3 + b);
                    If[n < limitLocal && squareQ[n],
                      Sow[n]
                    ],
                    {a, 1, aMax}
                  ]
                ]
              ],
              {b, 1, bMax}
            ]
          ][[2]];
          If[bucket === {},
            {},
            First[bucket]
          ]
        ]
      ],
      Range[2, cMax],
      Method -> "FinestGrained"
    ]
  ];
  squares = Union[Flatten[perC]];
  Total[squares]
];

solve[]
