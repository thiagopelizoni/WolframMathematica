(* Project Euler Problem 125 - https://projecteuler.net/problem=125

   We seek the sum of all numbers below 10^8 that are simultaneously decimal palindromes and representable as a sum of
   consecutive squares of positive integers, with at least two terms. Distinct palindromes are counted once even if they
   admit multiple representations.

   Let S(a, b) = a^2 + (a+1)^2 + ... + b^2 for integers 1 <= a < b. The admissible search space is bounded by S(1, b)
   and by the two-term lower envelope S(a, a+1) = 2 a^2 + 2 a + 1 < 10^8, so a is at most about 7*10^3 and b at most
   about 10^4. Hence the full interval enumeration is finite and moderate.

   Prefix sums reduce each interval evaluation to O(1): if P(k) = Sum_{i=1}^k i^2 and P(0) = 0, then
   S(a, b) = P(b) - P(a-1). Therefore all candidate consecutive-square sums can be generated by scanning each start a
   with increasing end b until the limit is crossed. This yields total arithmetic cost proportional to the number of
   feasible (a, b) pairs, empirically in the low tens of millions for the Euler bound, well within practical limits.

   Palindromicity is tested exactly via digit reversal in base 10, avoiding floating arithmetic. Deduplication is done by
   a final set union before summation, which enforces the problem's distinctness condition regardless of multiplicities of
   representation.

   Parallelization is embarrassingly parallel over disjoint start-index blocks. Each kernel receives one block, enumerates
   all palindromic sums from those starts independently, and returns a local list. Global aggregation is associative:
   lists are concatenated, then Union removes duplicates, and Total produces the final answer. No shared mutable state is
   required, so the computation is deterministic and race-free.

   The Wolfram Language implementation uses exact integers throughout, precomputes prefix sums once, applies ParallelMap
   to chunked start ranges, and wraps the complete pipeline in solve[] to return the single required integer.
*)

nCores = $ProcessorCount;
LaunchKernels[];

isPalindrome[n_Integer?Positive] := Module[{d},
  d = IntegerDigits[n];
  d === Reverse[d]
]

palindromicSumsForStart[start_Integer?Positive, prefix_List, limit_Integer?Positive] := Module[{b, v, bags},
  b = start + 1;
  bags = Reap[
    While[b + 1 <= Length[prefix],
      v = prefix[[b + 1]] - prefix[[start]];
      If[v >= limit, Break[]];
      If[isPalindrome[v], Sow[v]];
      b++
    ]
  ][[2]];
  If[bags === {}, {}, First[bags]]
]

palindromicChunk[chunk_List, prefix_List, limit_Integer?Positive] := Flatten[
  palindromicSumsForStart[#, prefix, limit] & /@ chunk
]

DistributeDefinitions[isPalindrome, palindromicSumsForStart, palindromicChunk];

solve[] := Module[{limit, maxTerm, prefix, maxStart, starts, chunkSize, chunks, partials, values},
  limit = 10^8;
  maxTerm = Floor[Sqrt[limit - 1]];
  prefix = Prepend[Accumulate[Range[maxTerm]^2], 0];
  maxStart = Floor[(Sqrt[2 limit - 1] - 1)/2];
  starts = Range[maxStart];
  chunkSize = Max[64, Ceiling[Length[starts]/(8 nCores)]];
  chunks = Table[starts[[i ;; Min[i + chunkSize - 1, Length[starts]]]], {i, 1, Length[starts], chunkSize}];
  partials = ParallelMap[palindromicChunk[#, prefix, limit] &, chunks];
  values = Union[Flatten[partials]];
  Total[values]
]

solve[]
