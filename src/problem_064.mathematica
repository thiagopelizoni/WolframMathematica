(*
Project Euler Problem 64: Odd Period Square Roots
URL: https://projecteuler.net/problem=064

Problem Statement:
The problem asks for the number of continued fraction expansions of the square roots of integers N (where N <= 10000)
that have an odd period length. We consider strictly non-square positive integers, as perfect squares have finite
expansions (period 0).

Mathematical Analysis:
For a non-square integer N, the continued fraction of sqrt(N) is periodic and of the form [a0; a1, a2, ..., ak, ...].
The sequence of partial quotients a_i is generated by the iterative algorithm:
m[0] = 0, d[0] = 1, a[0] = Floor[Sqrt[N]]
m[k+1] = d[k] * a[k] - m[k]
d[k+1] = (N - m[k+1]^2) / d[k]
a[k+1] = Floor[(a[0] + m[k+1]) / d[k+1]]
The period of the expansion corresponds to the sequence a1, ..., ar. A fundamental property of quadratic irrationals
sqrt(N) is that the period ends exactly when a[r] = 2 * a[0]. Thus, the length of the period is the smallest k >= 1
such that a[k] = 2 * a[0]. If N is a perfect square, the process terminates immediately or is considered to have
length 0.

Asymptotic Analysis and Feasibility:
The period length for sqrt(N) is generally O(Sqrt(N) Log(N)). For N <= 10000, the periods are small (typically < 200).
With only 10,000 integers to process, the total computational effort is trivial, requiring roughly 10^6 to 10^7
elementary arithmetic operations. This fits easily within standard time limits on a single core, and parallelization
makes it virtually instantaneous. The complexity class is well within polynomial time relative to the value of N.

Parallelization Strategy:
The calculation for each N is completely independent. We decompose the problem by distributing the integers
1 to 10000 across all available processor cores. Each core computes the period length for its assigned subset of
integers. We then aggregate the results by counting how many of these lengths are odd.

Implementation Strategy:
We use `Compile` to create an optimized function `periodLength` that implements the arithmetic recurrence relation
using machine integers for maximum speed. We then use `ParallelMap` to apply this function over the range of N,
ensuring dynamic load balancing. Finally, we apply `Count` with `OddQ` to determine the answer.
*)

nCores = $ProcessorCount;

periodLength = Compile[{{n, _Integer}},
   Module[{a0, m, d, a, len},
    a0 = Floor[Sqrt[N[n]]];
    If[a0 * a0 == n, Return[0]];
    m = 0;
    d = 1;
    a = a0;
    len = 0;
    While[True,
     m = d * a - m;
     d = Quotient[n - m^2, d];
     a = Quotient[a0 + m, d];
     len++;
     If[a == 2 * a0, Break[]];
    ];
    len
   ],
   CompilationTarget -> "WVM",
   RuntimeAttributes -> {Listable}
];

solve[] := Module[{results},
   DistributeDefinitions[periodLength];
   results = ParallelMap[periodLength, Range[10000]];
   Count[results, _?OddQ]
];

solve[]